1.싱글톤 사용 이유.
  - 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생.
  - 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 가능.
  - 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 함.
-----------------------------------------------
[클라이언트]----------[DI컨테이너(AppConfig)]

클라이언트A ---------> new memberService x01
    (1. memberService요청  2. memberService반환)
클라이언트B ---------> new memberService x02
    (1. memberService요청  2. memberService반환)
클라이언트C ---------> new memberService x03
    (1. memberService요청  2. memberService반환)
------------------------------------------------
클라이언트는 계속해서 요청을 하는데 위의 모습처럼 올때마다 생성을 하면 매번 객체를 새로 생성
따라서 메모리 낭비가 엄청나게 심해짐.
==>> 객체를 한개만 만들고 해당 객체를 공유하는 방법으로 사용(싱글톤패턴 사용)

2. 사용방법
  - 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
  - 그러므로 객체 인스턴스가 2개 이상 생성되지 않도록 막아야 한다.
    *private 생성자를 사용해서 외부에서 임의로 new 키원드를 사용하지 못하도록 막아야 함.

  1. static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.
  2. 이 객체 인스턴스가 필요하면 오직 getInstance()메서드를 통해서만 조회할 수 있다.
    이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
  3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서
    혹시라도 외부에서 new키워드로 객체 인스턴스가 생성되는 것을 막는다.

    스프링컨테이너로 AppConfig를 만든다면 자동으로 싱글톤으로 관리해주기 때문에
    따로 생성을 해주지 않아도 됨.

3. 단점
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존 관계상 클라이언트가 구체 클래스에 의존한다. -> DIP위반
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화 하기 어렵다.
  - private생성자로 자식 클래스를 만들기 어렵다.
  - 결론적으로 유연성이 매우 떨어짐
  - 그래서 안티패턴으로 불리기도 함.

4. 싱글톤 컨테이너(스프링 컨테이너)
  : 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
  지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.


  * 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
    (컨테이너는 객체를 하나만 생성해서 관리함, @bean//@autowired)
  * 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
  이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
  >> DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤 사용 가능.

  ###스프링의 기본 빈 등록 방식은 싱글톤이지만(거의 모든경우 사용),
  싱글톤 방식만 지원하는 것은 아니다.
  요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공 한다.###
  >>예제: SingletonService, SingletonTest

5. 싱긑톤 방식의 주의점.
  - 여러클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에
  싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
  - 무상태(stateless)로 설계해야 한다
    * 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    * 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
    * 가급적 읽기만 가능해야 한다.
    * 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal등을 사용
  - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!
  >>예제: StatefulService, StatefulServiceTest, StatelessService

6. @Configuration
  - AppConfig를 살펴보면
  memberService 빈: memberRepository()를 호출 -> new MemoryMemberRepository()호출
  orderService 빈: memberRepository()호출 -> new MemoryMemberRepository()호출

  결과적으로 각각 다른 2개의 MemoryMemberRepository가 생성되면서 싱글톤이 깨지는 것 같아 보인다.
  하지만 싱글톤 컨테이너에서 bean생성시 이미 생성했던 메서드라면 만들어져 있는 객체를 사용??
  >>예제: ConfigurationSingletonTest

7. @Configuration과 바이트 조작
  - 스프링 컨테이너는 싱글톤 레지스트리. 따라서 싱글톤 보장해줘야 함.
  - 싱글톤을 보장하기 위해서 바이트코드를 조작하는 라이브러리를 사용한다.
  - AppConfig 클래스 명 뒤에 xxxCGLIB가 붙어있는 것을 확인할 수 있다.
    이는 내가 만든 클래스가 아닌 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 이용해
    AppConfig클래스를 상속받은 새로운 클래스를 만들고, 스프링 빈으로 등록한 것이다.
    (AppConfig <-- AppConfig@CGLIB)
    >> 스프링 컨테이너에는 AppConfig@CGLIB가 등록되어 있음. 이 클래스가 싱글톤을 보장
    간단한 작동 방식은 Configuration들의 메서드를 오버라이드 해서 새롭게 작성
      이미 생성했던 메서드라면 스프링 컨테이너에서 찾아서 반환해주고
      없는 메서드라면 그때 새로 생성하고 스프링 컨테이너에 등록해준다.
      이러한 메커니즘은 나중에 AOP에서도 사용되는 메커니즘이다.

  - 만약 @Configuration 어노테이션을 안해준다면?
    바이트코드를 조작하는 CGLIB기술을 사용하지 않는다.
    따라서 ConfigruationSingletonTest의 configurationDeep를 실행하면
    memberRepository가 3번 호출되게 된다.
    --> 싱글톤이 깨지게 된다.
    --> 스프링 컨테이너가 쓸모 없어지게 된다.
    참고: autowired로 의존관계를 주입하면 해결할 수 있다. 하지만 복잡하다.
    그러므로 설정 정보에는 항상 configuration을 사용해주도록 하자.