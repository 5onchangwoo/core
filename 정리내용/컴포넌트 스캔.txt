1. 컴포넌트 스캔과 의존관계 자동 주입 시작하기.
  - @Bean이나 XML의 <bean>등을 통해서 설정 정보에 직접 등록할 스프링 빈을 나열 함.
  - 그 수가 많아지면 힘들어지기 때문에 스프링에서 설정정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능 제공.
  - 거기에 추가적으로 의존관계를 자동으로 주입해주는 @Autowired기능도 제공한다.
  -사용방법:
    @ComponentScan을 설정 정보에 붙여주기. >> AutoAppConfig참조
    (@Bean으로 등록한 클래스가 없음)
    그 후 스프링 빈으로 등록할 클래스들에 @Component를 붙여준다.(보통 구현체들에 붙임)
    또한 각 생성자들에 @Autowired를 붙여줌.

    주의점: 컴포넌트 스캔을 사용하면 @Configuration이 붙은 설정 정보도 자동으로 등록됨.
    그러므로 앞에서 만든 AppConfig, TestConfig,등과 같은 설정정보도 함께 등록&실행
    따라서 ExcludeFilters를 이용해 설정정보는 컴포넌트 스캔 대상에서 제외. (보통은 설정정보를 컴포넌트 스캔 대상에서 제외하지 않음)
    이유는 @Configuration에도 @Component가 붙어있기 때문

  -동작
    1) Component 스캔
      - 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
        * 빈 이름 기본 전략: MeberServiceImpl -> memberServiceImpl
        * 빈 이름 직접 지정: @Component("memberService")

    2) 의존 관계 자동 주입
      - 생성자에 @Autowired 지정시, 스프링 컨테이너가 자동으로 스프링 빈을 찾아서 주입.
      - 기본 조회 전략: 타입이 같은 빈을 찾아서 주입
        * getBean(MemberRepository.class)와 기본적으로 동일.
        * 파라미터가 많아도 전부 자동으로 주입해줌.

2. 탐색 위치와 기본 스캔 대상.
  @ComponentScan(
      basePackages = "hello.core"
  )
  - basePackages: 탐색할 패키지의 시작 위치를 지정. 해당 패키지를 포함한 하위 패키지들을 스캔한다.(그 외에 상위 패키지는 하지않음)
    * basePackages = {"hello.core", "hello.service"}와 같이 여러 패키지를 지정해줄 수 있음.
  - basePackagesClasses = 지정한 패키지의 클래스를 탐색 시작위치로 지정.
  (디폴트: 지정 해주지 않는다면 @ComponentSacn을 붙여준 클래스의 패키지가 시작 위치가 된다.)
  따라서 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것을 권장한다.
  또한 스프링부트의 설정 정보인 @SpringBootApplication도 최상단 패키지에 위치한다.(CoreApplication.java)

3. 컴포넌트 스캔 기본 대상
  @Component: 컴포넌트 스캔에서 사용
  @Controller: 스프링 MVC컨트롤러에서 사용
  @Service: 스프링 비즈니스 로직에서 사용
  @Repository: 스프링 접근 계층에서 사용
  @Configuration: 스프링 설정 정보에서 사용
  *************************************************************************************************
  참고: 애노테이션에는 상속관계라는 것이 없다.
  그래서 이렇게 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은
  자바 언어가 지원하는 기능이 아니고 스프링이 지원하는 기능
  **************************************************************************************************

  또한 각 애노테이션들은 스프링에서 부가 기능을 수행한다.
  @Controller: 스프링 MVC 컨트롤러로 인식
  @Repository: 스프링 데이터 접근 계층으로 인식, 데이터 계층의 예외를 스프링 예외로 변환
  @Configuration: 스프링 설정 정보로 인식, 스프링 빈이 싱글톤을 유지하도록 추가 처리
  @Service: 특별한 처리X, 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나라고 비즈니스 계층을 인식하는데 도움이 됨.
  **************************************************************************************************
  참고: useDefaultFilters 옵션은 기본적으로 켜져있음, 이 옵션을 끄면 기본 스캔 대상들이 제외된다.
  **************************************************************************************************

4. 필터
  - includeFilter: 컴포넌트 스캔 대상을 추가로 지정
  - excludeFilter: 컴포넌트 스캔에서 제외할 대상

5. 필터 옵션
  - ANNOTATION: 기본 값, 애노테이션을 인식해서 동작
    ex) org.example.SomeAnnotation
  - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작
    ex) org.example.SomeClass
  - ASPECTJ: AspectJ패턴 사용
    ex) org.example..*Service+
  - REGEX: 정규 표현식
    ex) org\.example\.Default.*
  - CUSTOM: TypeFilter이라는 인터페이스를 구현해서 처리
    ex) org.example.MyTypeFilter

  예를 들어 BeanA도 뺴고 싶으면 다음과 같이 추가.
  @ComponentSacn(
    includeFilters = {
        @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
    },
    excludeFilters = {
        @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class),
        @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class)
    }
  )

6. 중복 등록 충돌
  - 컴포넌트 스캔에서 같은 빈 이름을 등록할떄
    1. 자동 빈 등록 vs 자동 빈 등록
    2. 수동 빈 등록 vs 자동 빈 등록

  1) 자동 빈 등록 vs 자동 빈 등록
    : 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류 발생
      * ConflictingBeanDefinitionException(BeanDefinitionStoreException) 예외 발생
  2) 수동 빈등록 vs 자동 빈 등록
    : 수동 빈 등록이 오버라이딩함.
    즉 오류가 발생하지 않음. --> 의도하지 않은 버그가 발생할 수 있음
    따라서 최근에는 스프링 부트에서는 수동 빈 등록과 자동 빈 등록의 충돌 시 오류가 발생하도록 기본 값을 변경.
    따라서 스프링을 실행한다면 오류가 발생한다.
    만약 허용하고 싶다면 application.properties에
    "Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true"
    를 추가하면 된다.

